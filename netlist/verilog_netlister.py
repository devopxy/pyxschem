"""
Verilog netlister for PyXSchem.

Generates Verilog netlist from a schematic context with resolved connectivity.
"""

import logging
from typing import Optional, List, Set
from pathlib import Path

from pyxschem.core.context import SchematicContext
from pyxschem.core.symbol import Symbol, Instance, SymbolType
from pyxschem.core.property_parser import get_tok_value
from pyxschem.netlist.connectivity import ConnectivityAnalyzer
from pyxschem.netlist.format_processor import FormatProcessor

logger = logging.getLogger(__name__)


class VerilogNetlister:
    """Generates Verilog netlist from a schematic."""

    def __init__(self, context: SchematicContext):
        self._context = context

    def generate(self) -> str:
        """Generate complete Verilog netlist."""
        analyzer = ConnectivityAnalyzer(self._context)
        net_map = analyzer.analyze()

        lines: List[str] = []

        # Header
        lines.append(f"// sch_path: {self._context.current_name or 'untitled'}")
        lines.append("// Generated by PyXSchem")
        lines.append("")

        # Global properties
        if self._context.verilog_prop:
            for line in self._context.verilog_prop.splitlines():
                if line.strip():
                    lines.append(line.strip())
            lines.append("")

        # Module declaration
        module_name, ports, port_dirs = self._get_module_info()
        if ports:
            lines.append(f"module {module_name} ({', '.join(ports)});")
        else:
            lines.append(f"module {module_name};")
        lines.append("")

        # Port declarations
        for name, direction in port_dirs.items():
            lines.append(f"  {direction} {name};")
        if port_dirs:
            lines.append("")

        # Wire declarations for internal nets
        internal_nets = self._get_internal_nets(net_map, set(ports) if ports else set())
        for net in sorted(internal_nets):
            lines.append(f"  wire {net};")
        if internal_nets:
            lines.append("")

        # Instance declarations
        for inst in self._context.instances:
            sym = self._get_symbol(inst)
            if sym is None:
                continue

            inst_line = self._process_instance(inst, sym)
            if inst_line:
                lines.append(f"  {inst_line}")

        lines.append("")
        lines.append("endmodule")
        lines.append("")

        netlist = "\n".join(lines)
        logger.info("Generated Verilog netlist: %d lines", len(lines))
        return netlist

    def _get_module_info(self):
        """Extract module name and port info from pin instances."""
        ctx = self._context
        ports: List[str] = []
        port_dirs = {}

        for inst in ctx.instances:
            sym = self._get_symbol(inst)
            if sym is None:
                continue

            lab = get_tok_value(inst.prop_ptr or "", "lab") if inst.prop_ptr else ""
            if not lab:
                lab = inst.lab or ""

            if sym.type == SymbolType.IPIN:
                ports.append(lab)
                port_dirs[lab] = "input"
            elif sym.type == SymbolType.OPIN:
                ports.append(lab)
                port_dirs[lab] = "output"
            elif sym.type == SymbolType.IOPIN:
                ports.append(lab)
                port_dirs[lab] = "inout"

        name = Path(ctx.current_name).stem if ctx.current_name else "unnamed"
        return name, ports, port_dirs

    def _get_internal_nets(self, net_map, port_names: Set[str]) -> Set[str]:
        """Get set of internal net names (not ports, not auto-named)."""
        internal = set()
        for net_name in net_map:
            if net_name not in port_names and not net_name.startswith("#"):
                internal.add(net_name)
        return internal

    def _process_instance(self, inst: Instance, sym: Symbol) -> Optional[str]:
        """Process one instance into a Verilog line."""
        sym_type = sym.type or ""

        if sym_type in (SymbolType.LABEL, SymbolType.IPIN, SymbolType.OPIN,
                        SymbolType.IOPIN, SymbolType.NOCONN):
            return None

        if inst.prop_ptr and get_tok_value(inst.prop_ptr, "verilog_ignore") == "true":
            return None

        # Use verilog_format if available
        fmt = sym.verilog_format
        if fmt:
            pin_names = sym.get_pin_names()
            node_names = inst.node if inst.node else ["?"] * len(pin_names)
            return FormatProcessor.process(
                fmt=fmt,
                inst_props=inst.prop_ptr or "",
                templ_props=sym.templ or "",
                inst_name=inst.instname or "?",
                sym_name=sym.name,
                pin_names=pin_names,
                node_names=node_names,
            ).strip()

        # Default: module_name instance_name (.pin1(net1), .pin2(net2), ...);
        pin_names = sym.get_pin_names()
        node_names = inst.node if inst.node else ["?"] * len(pin_names)
        base = sym.name.rsplit("/", 1)[-1].replace(".sym", "")

        connections = []
        for pn, nn in zip(pin_names, node_names):
            connections.append(f".{pn}({nn or '?'})")

        conn_str = ", ".join(connections)
        return f"{base} {inst.instname or '?'} ({conn_str});"

    def _get_symbol(self, inst: Instance) -> Optional[Symbol]:
        ctx = self._context
        if inst.ptr >= 0 and inst.ptr < len(ctx.symbols):
            return ctx.symbols[inst.ptr]
        return ctx.get_symbol(inst.name)
