"""
SPICE netlister for PyXSchem.

Generates a SPICE netlist from a schematic context with resolved connectivity.
Handles subcircuit wrappers, instance format strings, global properties,
and special symbol types.
"""

import os
import logging
from typing import Optional, List
from pathlib import Path

from pyxschem.core.context import SchematicContext
from pyxschem.core.symbol import Symbol, Instance, SymbolType
from pyxschem.core.property_parser import get_tok_value
from pyxschem.netlist.connectivity import ConnectivityAnalyzer
from pyxschem.netlist.format_processor import FormatProcessor

logger = logging.getLogger(__name__)


class SpiceNetlister:
    """
    Generates SPICE netlist from a schematic.

    Output structure:
    1. Header comment
    2. Global schematic properties (.include, .param, etc.)
    3. Subcircuit header (if schematic defines a subcircuit)
    4. Instance lines (processed through symbol format strings)
    5. Raw SPICE from netlist_commands instances
    6. Subcircuit footer
    """

    def __init__(self, context: SchematicContext):
        self._context = context

    def generate(self) -> str:
        """
        Generate complete SPICE netlist.

        Returns:
            SPICE netlist as a string
        """
        # Run connectivity analysis
        analyzer = ConnectivityAnalyzer(self._context)
        net_map = analyzer.analyze()

        lines: List[str] = []

        # Header
        sch_name = self._context.current_name or "untitled"
        lines.append(f"** sch_path: {sch_name}")
        lines.append(f"** Generated by PyXSchem")
        lines.append("")

        # Global properties (from schematic properties)
        self._emit_global_props(lines)

        # Check if this schematic defines a subcircuit
        subckt_name, subckt_ports = self._get_subckt_info()
        if subckt_name:
            port_str = " ".join(subckt_ports) if subckt_ports else ""
            lines.append(f".subckt {subckt_name} {port_str}")
            lines.append("")

        # Process each instance
        for inst in self._context.instances:
            sym = self._get_symbol(inst)
            if sym is None:
                continue

            inst_line = self._process_instance(inst, sym)
            if inst_line:
                lines.append(inst_line)

        # Close subcircuit
        if subckt_name:
            lines.append("")
            lines.append(f".ends {subckt_name}")

        # Trailing newline
        lines.append("")

        netlist = "\n".join(lines)
        logger.info("Generated SPICE netlist: %d lines", len(lines))
        return netlist

    def _emit_global_props(self, lines: List[str]) -> None:
        """Emit global schematic properties."""
        if self._context.schprop:
            for prop_line in self._context.schprop.splitlines():
                stripped = prop_line.strip()
                if stripped:
                    lines.append(stripped)
            lines.append("")

    def _get_subckt_info(self):
        """Check if schematic defines a subcircuit and extract ports."""
        ctx = self._context

        # Look for ipin/opin/iopin instances
        ports: List[str] = []
        ipins: List[str] = []
        opins: List[str] = []
        iopins: List[str] = []

        for inst in ctx.instances:
            sym = self._get_symbol(inst)
            if sym is None:
                continue

            lab = None
            if inst.prop_ptr:
                lab = get_tok_value(inst.prop_ptr, "lab")
            if not lab:
                lab = inst.lab

            if not lab:
                continue

            if sym.type == SymbolType.IPIN:
                ipins.append(lab)
            elif sym.type == SymbolType.OPIN:
                opins.append(lab)
            elif sym.type == SymbolType.IOPIN:
                iopins.append(lab)

        if ipins or opins or iopins:
            ports = ipins + opins + iopins
            # Derive subckt name from filename
            name = Path(ctx.current_name).stem if ctx.current_name else "unnamed"
            return name, ports

        return None, None

    def _process_instance(self, inst: Instance, sym: Symbol) -> Optional[str]:
        """Process one instance into a SPICE netlist line."""
        sym_type = sym.type or ""

        # Skip labels, pins - they're connectivity only
        if sym_type in (SymbolType.LABEL, SymbolType.IPIN, SymbolType.OPIN,
                        SymbolType.IOPIN, SymbolType.NOCONN):
            return None

        # Skip ignored instances
        if inst.prop_ptr and get_tok_value(inst.prop_ptr, "spice_ignore") == "true":
            return None

        # Raw SPICE from netlist_commands
        if sym_type == SymbolType.NETLIST_COMMANDS:
            value = get_tok_value(inst.prop_ptr or "", "value") if inst.prop_ptr else ""
            return value if value else None

        # Use symbol's format string
        fmt = sym.format
        if not fmt:
            # Default format: @name @pinlist @symname @body
            fmt = "@name @pinlist @symname @body"

        # Get pin and node info
        pin_names = sym.get_pin_names()
        node_names = inst.node if inst.node else ["?"] * len(pin_names)

        # Process format string
        result = FormatProcessor.process(
            fmt=fmt,
            inst_props=inst.prop_ptr or "",
            templ_props=sym.templ or "",
            inst_name=inst.instname or "?",
            sym_name=sym.name,
            pin_names=pin_names,
            node_names=node_names,
        )

        return result.strip() if result else None

    def _get_symbol(self, inst: Instance) -> Optional[Symbol]:
        """Get symbol for an instance."""
        ctx = self._context
        if inst.ptr >= 0 and inst.ptr < len(ctx.symbols):
            return ctx.symbols[inst.ptr]
        return ctx.get_symbol(inst.name)
