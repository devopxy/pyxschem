"""
VHDL netlister for PyXSchem.

Generates VHDL netlist from a schematic context with resolved connectivity.
"""

import logging
from typing import Optional, List, Set, Dict
from pathlib import Path

from pyxschem.core.context import SchematicContext
from pyxschem.core.symbol import Symbol, Instance, SymbolType
from pyxschem.core.property_parser import get_tok_value
from pyxschem.netlist.connectivity import ConnectivityAnalyzer
from pyxschem.netlist.format_processor import FormatProcessor

logger = logging.getLogger(__name__)


class VhdlNetlister:
    """Generates VHDL netlist from a schematic."""

    def __init__(self, context: SchematicContext):
        self._context = context

    def generate(self) -> str:
        """Generate complete VHDL netlist."""
        analyzer = ConnectivityAnalyzer(self._context)
        net_map = analyzer.analyze()

        lines: List[str] = []

        # Header
        lines.append(f"-- sch_path: {self._context.current_name or 'untitled'}")
        lines.append("-- Generated by PyXSchem")
        lines.append("")

        # Global VHDL properties (library, use clauses)
        if self._context.vhdl_prop:
            for line in self._context.vhdl_prop.splitlines():
                if line.strip():
                    lines.append(line.strip())
            lines.append("")

        # Entity declaration
        entity_name, ports = self._get_entity_info()
        lines.append(f"entity {entity_name} is")
        if ports:
            lines.append("  port (")
            for i, (name, direction, sig_type) in enumerate(ports):
                sep = ";" if i < len(ports) - 1 else ""
                lines.append(f"    {name} : {direction} {sig_type}{sep}")
            lines.append("  );")
        lines.append(f"end {entity_name};")
        lines.append("")

        # Architecture
        lines.append(f"architecture arch_{entity_name} of {entity_name} is")
        lines.append("")

        # Signal declarations for internal nets
        port_names = {p[0] for p in ports}
        internal_nets = self._get_internal_nets(net_map, port_names)
        for net in sorted(internal_nets):
            lines.append(f"  signal {net} : std_logic;")
        if internal_nets:
            lines.append("")

        # Component declarations
        components = self._get_component_declarations()
        for comp_lines in components.values():
            for cl in comp_lines:
                lines.append(f"  {cl}")
            lines.append("")

        lines.append("begin")
        lines.append("")

        # Instance declarations
        for inst in self._context.instances:
            sym = self._get_symbol(inst)
            if sym is None:
                continue

            inst_lines = self._process_instance(inst, sym)
            if inst_lines:
                for il in inst_lines:
                    lines.append(f"  {il}")

        lines.append("")
        lines.append(f"end arch_{entity_name};")
        lines.append("")

        netlist = "\n".join(lines)
        logger.info("Generated VHDL netlist: %d lines", len(lines))
        return netlist

    def _get_entity_info(self):
        """Extract entity name and port info from pin instances."""
        ctx = self._context
        ports = []

        for inst in ctx.instances:
            sym = self._get_symbol(inst)
            if sym is None:
                continue

            lab = get_tok_value(inst.prop_ptr or "", "lab") if inst.prop_ptr else ""
            if not lab:
                lab = inst.lab or ""

            sig_type = "std_logic"
            if inst.prop_ptr:
                st = get_tok_value(inst.prop_ptr, "sig_type")
                if st:
                    sig_type = st

            if sym.type == SymbolType.IPIN:
                ports.append((lab, "in", sig_type))
            elif sym.type == SymbolType.OPIN:
                ports.append((lab, "out", sig_type))
            elif sym.type == SymbolType.IOPIN:
                ports.append((lab, "inout", sig_type))

        name = Path(ctx.current_name).stem if ctx.current_name else "unnamed"
        return name, ports

    def _get_internal_nets(self, net_map, port_names: Set[str]) -> Set[str]:
        """Get internal net names."""
        internal = set()
        for net_name in net_map:
            if net_name not in port_names and not net_name.startswith("#"):
                internal.add(net_name)
        return internal

    def _get_component_declarations(self) -> Dict[str, List[str]]:
        """Generate component declarations for used symbols."""
        seen: Dict[str, List[str]] = {}
        for inst in self._context.instances:
            sym = self._get_symbol(inst)
            if sym is None:
                continue

            sym_type = sym.type or ""
            if sym_type in (SymbolType.LABEL, SymbolType.IPIN, SymbolType.OPIN,
                            SymbolType.IOPIN, SymbolType.NOCONN, SymbolType.NETLIST_COMMANDS):
                continue

            base = sym.name.rsplit("/", 1)[-1].replace(".sym", "")
            if base in seen:
                continue

            pin_names = sym.get_pin_names()
            if not pin_names:
                continue

            comp_lines = [f"component {base}"]
            comp_lines.append("  port (")
            for i, pn in enumerate(pin_names):
                sep = ";" if i < len(pin_names) - 1 else ""
                comp_lines.append(f"    {pn} : std_logic{sep}")
            comp_lines.append("  );")
            comp_lines.append(f"end component;")

            seen[base] = comp_lines

        return seen

    def _process_instance(self, inst: Instance, sym: Symbol) -> Optional[List[str]]:
        """Process one instance into VHDL lines."""
        sym_type = sym.type or ""

        if sym_type in (SymbolType.LABEL, SymbolType.IPIN, SymbolType.OPIN,
                        SymbolType.IOPIN, SymbolType.NOCONN):
            return None

        if inst.prop_ptr and get_tok_value(inst.prop_ptr, "vhdl_ignore") == "true":
            return None

        # Use vhdl_format if available
        if sym.vhdl_format:
            pin_names = sym.get_pin_names()
            node_names = inst.node if inst.node else ["?"] * len(pin_names)
            result = FormatProcessor.process(
                fmt=sym.vhdl_format,
                inst_props=inst.prop_ptr or "",
                templ_props=sym.templ or "",
                inst_name=inst.instname or "?",
                sym_name=sym.name,
                pin_names=pin_names,
                node_names=node_names,
            ).strip()
            return [result] if result else None

        # Default: instance_name : component_name port map (pin1 => net1, ...);
        pin_names = sym.get_pin_names()
        node_names = inst.node if inst.node else ["?"] * len(pin_names)
        base = sym.name.rsplit("/", 1)[-1].replace(".sym", "")

        port_maps = []
        for pn, nn in zip(pin_names, node_names):
            port_maps.append(f"{pn} => {nn or '?'}")

        inst_name = inst.instname or "?"
        return [f"{inst_name} : {base} port map ({', '.join(port_maps)});"]

    def _get_symbol(self, inst: Instance) -> Optional[Symbol]:
        ctx = self._context
        if inst.ptr >= 0 and inst.ptr < len(ctx.symbols):
            return ctx.symbols[inst.ptr]
        return ctx.get_symbol(inst.name)
